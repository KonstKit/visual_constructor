# Детальный план разработки для ИИ-агента: Пошаговое руководство по созданию системы визуального построения данных

## Понимание подхода к разработке с ИИ-агентом

Прежде чем мы погрузимся в детальный план, давайте разберемся, почему правильная структура итераций критически важна при работе с ИИ-агентами разработки. Представьте, что вы учите ребенка собирать сложный конструктор - вы не даете ему сразу тысячу деталей, а начинаете с базовой конструкции и постепенно добавляете новые элементы. Точно так же работает и ИИ-агент: он наиболее эффективен, когда может сосредоточиться на небольшой, четко определенной задаче.

Ключевые принципы, которые мы будем использовать в нашем плане:

Во-первых, каждая итерация должна быть самодостаточной и тестируемой. Это означает, что после каждого шага у нас должен быть работающий код, который можно запустить и проверить. Это как строительство дома - сначала фундамент, потом стены, и только затем крыша.

Во-вторых, мы будем использовать принцип "контекстного якоря". В начале каждой новой сессии с ИИ-агентом мы будем предоставлять краткое резюме того, что уже сделано, и четкое описание следующего шага. Это похоже на то, как опытный руководитель проекта начинает каждое утреннее совещание с напоминания о текущем статусе.

В-третьих, мы структурируем код таким образом, чтобы минимизировать зависимости между модулями на ранних этапах. Это позволит агенту работать с изолированными компонентами, не беспокоясь о сложных взаимосвязях.

## Фаза 0: Подготовка окружения и базовой структуры

### Итерация 0.1: Создание структуры проекта

Начнем с создания базовой структуры проекта. Это критически важный шаг, который задаст правильную организацию для всей последующей разработки.

**Инструкция для ИИ-агента:**
```
Создай базовую структуру Maven-проекта для Spring Boot приложения с названием "data-flow-builder". 
Версия Spring Boot: 2.7.14
Java версия: 11
Группа: com.dataflow
Артефакт: data-flow-builder

Структура должна включать:
- Основной pom.xml с базовыми зависимостями (Spring Boot Starter Web, Spring Boot Starter Data JPA, Lombok)
- Пакетную структуру: controller, service, repository, model, config, util
- Главный класс приложения DataFlowBuilderApplication
- Файл application.yml с базовыми настройками
- README.md с описанием проекта
```

### Итерация 0.2: Настройка базы данных и Flyway

После создания структуры нам нужно настроить подключение к базе данных. Мы будем использовать PostgreSQL для внутреннего хранилища метаданных и H2 для тестов.

**Инструкция для ИИ-агента:**
```
Добавь в проект поддержку PostgreSQL и настрой Flyway для миграций:
1. Добавь зависимости в pom.xml: postgresql driver, flyway-core, h2 database (для тестов)
2. Создай профили в application.yml: dev (PostgreSQL) и test (H2)
3. Создай первую миграцию V1__init_schema.sql в resources/db/migration
   Миграция должна создать таблицы:
   - connections (id, name, database_type, connection_string, created_at, updated_at)
   - visual_algorithms (id, name, description, blockly_xml, jexl_script, created_at, updated_at)
4. Создай JPA entities для этих таблиц в пакете model
5. Создай простой тест для проверки, что приложение запускается
```

### Итерация 0.3: Базовый REST контроллер и Swagger

Теперь создадим базовый API endpoint и настроим документацию. Это позволит нам проверить, что основа приложения работает корректно.

**Инструкция для ИИ-агента:**
```
Создай базовый REST API с документацией:
1. Добавь зависимость springdoc-openapi-ui версии 1.6.15
2. Создай HealthController с endpoint GET /api/health, который возвращает статус приложения
3. Создай ConnectionController с базовыми CRUD операциями для connections
4. Настрой Swagger UI на пути /swagger-ui.html
5. Создай интеграционный тест для HealthController
```

## Фаза 1: Модуль работы с базами данных

### Итерация 1.1: Абстракция для работы с различными БД

Начнем с создания абстрактного слоя для работы с различными типами баз данных. Это основа всей системы.

**Инструкция для ИИ-агента:**
```
Создай абстракцию для работы с различными типами БД:
1. Создай интерфейс DatabaseMetadataExtractor в пакете database.metadata
   Методы: extractSchema(Connection connection), testConnection(ConnectionConfig config)
2. Создай класс DatabaseSchema который содержит список TableInfo
3. Создай класс TableInfo с полями: name, columns (List<ColumnInfo>), foreignKeys (List<ForeignKeyInfo>)
4. Создай класс ColumnInfo с полями: name, dataType, nullable, primaryKey
5. Создай enum DatabaseType со значениями: POSTGRESQL, MYSQL, ORACLE, SQLSERVER
6. Напиши unit тесты для моделей данных
```

### Итерация 1.2: Реализация для PostgreSQL

Теперь реализуем конкретный экстрактор для PostgreSQL. Начнем с одного типа БД, чтобы отладить процесс.

**Инструкция для ИИ-агента:**
```
Реализуй PostgreSQLMetadataExtractor:
1. Создай класс PostgreSQLMetadataExtractor implements DatabaseMetadataExtractor
2. Реализуй метод extractSchema используя DatabaseMetaData из JDBC
3. Добавь обработку специфичных для PostgreSQL типов данных
4. Создай вспомогательный класс JdbcUtils для безопасной работы с ResultSet
5. Напиши интеграционный тест используя Testcontainers с PostgreSQL
   Тест должен создать тестовую схему и проверить корректность извлечения
```

### Итерация 1.3: Фабрика экстракторов и кеширование

Создадим фабрику для управления различными экстракторами и добавим кеширование для улучшения производительности.

**Инструкция для ИИ-агента:**
```
Создай фабрику и добавь кеширование:
1. Создай DatabaseMetadataExtractorFactory с методом getExtractor(DatabaseType type)
2. Зарегистрируй PostgreSQLMetadataExtractor в фабрике
3. Добавь зависимость spring-boot-starter-cache
4. Создай CachedDatabaseMetadataService который оборачивает вызовы к экстракторам
5. Настрой кеширование с TTL 5 минут используя @Cacheable
6. Создай тест проверяющий, что кеширование работает (второй вызов не обращается к БД)
```

### Итерация 1.4: REST API для работы с метаданными

Теперь создадим API endpoints для работы с метаданными баз данных.

**Инструкция для ИИ-агента:**
```
Создай REST API для метаданных:
1. Создай DatabaseMetadataController с endpoints:
   - POST /api/connections/{id}/extract-schema - запускает извлечение схемы
   - GET /api/connections/{id}/schema - возвращает закешированную схему
2. Создай DTO классы для API: SchemaDTO, TableDTO, ColumnDTO
3. Используй MapStruct для маппинга между entity и DTO (добавь зависимость)
4. Добавь обработку ошибок с помощью @ControllerAdvice
5. Напиши интеграционные тесты для контроллера
```

## Фаза 2: Визуализация схемы базы данных

### Итерация 2.1: Подготовка frontend структуры

Начнем создавать frontend часть приложения. Сначала настроим базовую структуру React приложения.

**Инструкция для ИИ-агента:**
```
Создай базовую структуру React приложения:
1. В корне проекта создай папку frontend
2. Инициализируй React приложение с TypeScript используя Vite
3. Установи основные зависимости: axios, react-router-dom, @mui/material
4. Создай базовую структуру папок: components, pages, services, utils, types
5. Настрой proxy для API вызовов к backend (localhost:8080)
6. Создай базовый Layout компонент с navigation
```

### Итерация 2.2: Сервис для работы с API

Создадим типизированный сервис для работы с backend API.

**Инструкция для ИИ-агента:**
```
Создай сервисный слой для API:
1. Создай типы TypeScript в types/api.ts для: Connection, Schema, Table, Column
2. Создай services/api.ts с axios instance и базовой конфигурацией
3. Создай services/connectionService.ts с методами:
   - getConnections(), getConnection(id), createConnection(data)
   - extractSchema(connectionId), getSchema(connectionId)
4. Добавь перехватчики для обработки ошибок и добавления токенов
5. Создай хук useApi для удобной работы с загрузкой и ошибками
```

### Итерация 2.3: Компонент визуализации схемы с D3.js

Теперь создадим компонент для визуализации схемы базы данных.

**Инструкция для ИИ-агента:**
```
Создай компонент визуализации схемы:
1. Установи d3 и @types/d3
2. Создай компонент SchemaVisualizer который принимает схему как prop
3. Реализуй отрисовку таблиц как прямоугольников с списком полей
4. Добавь связи между таблицами на основе foreign keys (используй d3.line)
5. Реализуй zoom и pan функциональность
6. Добавь выделение таблицы при клике
7. Создай storybook story для компонента с тестовыми данными
```

### Итерация 2.4: Интерактивность и фильтрация

Добавим интерактивные возможности к визуализации.

**Инструкция для ИИ-агента:**
```
Расширь функциональность визуализации:
1. Добавь панель поиска для фильтрации таблиц по имени
2. Реализуй сворачивание/разворачивание списка колонок в таблице
3. Добавь контекстное меню при правом клике на таблицу с опциями:
   - Добавить в алгоритм
   - Показать связанные таблицы
   - Копировать имя
4. Реализуй мини-карту для навигации по большим схемам
5. Добавь экспорт схемы в PNG
```

## Фаза 3: Визуальный конструктор алгоритмов - Базовая интеграция Blockly

### Итерация 3.1: Интеграция Blockly в React

Начнем интеграцию Blockly в наше React приложение.

**Инструкция для ИИ-агента:**
```
Интегрируй Blockly в React:
1. Установи blockly и создай обертку BlocklyWorkspace компонент
2. Настрой базовый toolbox с стандартными категориями Blockly
3. Создай хук useBlockly для управления workspace
4. Реализуй сохранение и загрузку workspace в XML формате
5. Добавь кнопки: Сохранить, Загрузить, Очистить, Отменить/Повторить
6. Создай страницу AlgorithmBuilder с интегрированным Blockly
```

### Итерация 3.2: Первые кастомные блоки для работы с БД

Создадим первые кастомные блоки специфичные для нашей системы.

**Инструкция для ИИ-агента:**
```
Создай кастомные блоки для работы с БД:
1. Создай файл customBlocks/databaseBlocks.ts
2. Реализуй блок 'db_query' для запроса к таблице:
   - Input для имени таблицы (dropdown с доступными таблицами)
   - Input для условия WHERE
   - Output типа Array
3. Реализуй блок 'db_get_field' для получения поля из записи
4. Создай генераторы JEXL кода для этих блоков
5. Добавь блоки в toolbox в категорию "База данных"
6. Напиши тесты для генерации кода
```

### Итерация 3.3: Блоки для работы с коллекциями

Расширим набор блоков для работы с массивами данных.

**Инструкция для ИИ-агента:**
```
Создай блоки для обработки коллекций:
1. Создай файл customBlocks/collectionBlocks.ts
2. Реализуй блоки:
   - collection_filter: фильтрация массива по условию
   - collection_map: преобразование элементов массива  
   - collection_reduce: агрегация (сумма, среднее, мин, макс)
   - collection_sort: сортировка по полю
3. Для каждого блока создай JEXL генератор
4. Добавь визуальные индикаторы типов (цвета для Array, Object, String)
5. Создай примеры использования в demo workspace
```

### Итерация 3.4: Интеграция с выбором таблиц из схемы

Свяжем визуализацию схемы БД с конструктором алгоритмов.

**Инструкция для ИИ-агента:**
```
Создай интеграцию между схемой и Blockly:
1. Добавь в SchemaVisualizer callback onTableSelect
2. При выборе таблицы в схеме, создавай соответствующий блок в Blockly
3. Реализуй drag-and-drop таблицы из схемы в workspace
4. Создай динамический dropdown в блоке db_query с актуальными таблицами
5. Добавь автодополнение для имен полей на основе выбранной таблицы
6. Синхронизируй изменения схемы с доступными опциями в блоках
```

## Фаза 4: Конструктор регулярных выражений

### Итерация 4.1: Базовый UI конструктора регулярных выражений

Создадим отдельный компонент для визуального построения регулярных выражений.

**Инструкция для ИИ-агента:**
```
Создай базовый конструктор регулярных выражений:
1. Создай компонент RegexBuilder с панелями:
   - Палитра элементов (литералы, классы символов, квантификаторы)
   - Рабочая область для составления выражения
   - Панель тестирования с примерами
2. Реализуй drag-and-drop элементов в рабочую область
3. Создай визуальное представление для базовых элементов:
   - Текстовый литерал (зеленый блок)
   - Класс символов (синий блок)
   - Квантификатор (оранжевый блок)
4. Реализуй генерацию regex строки из визуальных блоков
5. Добавь live preview сгенерированного выражения
```

### Итерация 4.2: Backend для регулярных выражений

Создадим backend поддержку для работы с регулярными выражениями.

**Инструкция для ИИ-агента:**
```
Создай backend сервис для regex:
1. Создай RegexService с методами:
   - validateRegex(String pattern): проверка корректности
   - testRegex(String pattern, List<String> testCases): тестирование
   - getMatches(String pattern, String text): поиск совпадений
2. Создай библиотеку готовых шаблонов RegexTemplateLibrary
3. Добавь REST endpoints в RegexController:
   - POST /api/regex/validate
   - POST /api/regex/test
   - GET /api/regex/templates
4. Реализуй кеширование скомпилированных Pattern объектов
5. Напиши тесты для всех методов
```

### Итерация 4.3: Интеграция regex builder в Blockly

Встроим конструктор регулярных выражений в основной конструктор алгоритмов.

**Инструкция для ИИ-агента:**
```
Интегрируй RegexBuilder в Blockly блоки:
1. Создай блок regex_match с кнопкой открытия визуального редактора
2. При клике открывай модальное окно с RegexBuilder
3. Сохраняй созданное выражение обратно в блок
4. Добавь preview выражения прямо на блоке
5. Создай блоки: regex_extract, regex_replace, regex_split
6. Добавь возможность сохранения часто используемых выражений
```

## Фаза 5: Движок выполнения JEXL

### Итерация 5.1: Базовая настройка JEXL движка

Настроим JEXL движок с необходимыми ограничениями безопасности.

**Инструкция для ИИ-агента:**
```
Настрой JEXL движок:
1. Добавь зависимость commons-jexl3 версии 3.3
2. Создай JexlEngineConfig с настройками безопасности:
   - Ограничь доступные классы только безопасными
   - Настрой максимальное время выполнения скрипта
   - Ограничь размер используемой памяти
3. Создай JexlExecutionService с методом execute
4. Реализуй перехват и обработку ошибок выполнения
5. Создай тесты с различными скриптами включая некорректные
```

### Итерация 5.2: Кастомные функции для JEXL

Расширим JEXL нашими специфичными функциями.

**Инструкция для ИИ-агента:**
```
Создай кастомные функции для JEXL:
1. Создай класс DatabaseFunctions с методами:
   - query(String table, String where)
   - count(String table, String where)
   - exists(String table, String where)
2. Создай RegexFunctions с методами из RegexService
3. Создай UtilityFunctions с полезными методами:
   - formatDate, parseDate, addDays
   - round, ceil, floor для чисел
   - trim, lowercase, uppercase для строк
4. Зарегистрируй все функции в JEXL контексте
5. Создай документацию по всем доступным функциям
```

### Итерация 5.3: Выполнение алгоритмов с прогрессом

Реализуем выполнение длительных алгоритмов с отслеживанием прогресса.

**Инструкция для ИИ-агента:**
```
Реализуй асинхронное выполнение:
1. Создай AlgorithmExecutionService с поддержкой CompletableFuture
2. Реализуй ExecutionProgress класс для отслеживания прогресса
3. Добавь WebSocket endpoint для отправки прогресса клиенту
4. Создай возможность отмены выполнения алгоритма
5. Реализуй сохранение результатов выполнения в БД
6. Добавь ограничение на количество параллельных выполнений
```

## Фаза 6: Экспорт и интеграции

### Итерация 6.1: Модуль экспорта данных

Создадим универсальный модуль для экспорта данных в различные форматы.

**Инструкция для ИИ-агента:**
```
Создай модуль экспорта:
1. Создай интерфейс DataExporter с методом export(Object data, ExportConfig config)
2. Реализуй экспортеры:
   - JsonExporter с настройками форматирования
   - XmlExporter с поддержкой XSD схемы
   - CsvExporter с настраиваемыми разделителями
3. Создай ExporterFactory для выбора нужного экспортера
4. Добавь streaming поддержку для больших объемов данных
5. Реализуй сжатие результатов (zip, gzip)
```

### Итерация 6.2: REST API интеграция

Добавим возможность отправки данных через REST API.

**Инструкция для ИИ-агента:**
```
Реализуй REST API интеграцию:
1. Создай RestApiIntegration класс с использованием WebClient
2. Добавь поддержку различных типов аутентификации:
   - Basic Auth
   - Bearer Token  
   - API Key (header/query)
3. Реализуй retry логику с exponential backoff
4. Добавь логирование всех запросов и ответов
5. Создай UI компонент для настройки REST endpoint
6. Напиши интеграционные тесты с WireMock
```

### Итерация 6.3: Kafka интеграция

Добавим поддержку отправки данных в Apache Kafka.

**Инструкция для ИИ-агента:**
```
Реализуй Kafka интеграцию:
1. Добавь зависимость spring-kafka
2. Создай KafkaIntegration с настраиваемым producer
3. Реализуй сериализацию данных (JSON, Avro)
4. Добавь обработку ошибок и retry политику
5. Создай UI для настройки Kafka параметров
6. Используй Testcontainers для интеграционных тестов
```

## Фаза 7: Финальная интеграция и оптимизация

### Итерация 7.1: Полная интеграция frontend и backend

Объединим все компоненты в единое приложение.

**Инструкция для ИИ-агента:**
```
Выполни полную интеграцию:
1. Создай главную страницу Dashboard со статистикой
2. Реализуй полный flow от выбора БД до экспорта данных
3. Добавь сохранение и загрузку алгоритмов
4. Реализуй версионирование алгоритмов
5. Добавь возможность делиться алгоритмами между пользователями
6. Создай E2E тесты основных сценариев с Cypress
```

### Итерация 7.2: Производительность и мониторинг

Оптимизируем производительность и добавим мониторинг.

**Инструкция для ИИ-агента:**
```
Добавь мониторинг и оптимизацию:
1. Интегрируй Spring Boot Actuator
2. Добавь метрики с Micrometer
3. Настрой connection pooling для БД
4. Реализуй пагинацию для больших результатов
5. Добавь индексы в БД где необходимо
6. Настрой production профиль с оптимальными параметрами
```

### Итерация 7.3: Docker и документация

Подготовим приложение к развертыванию.

**Инструкция для ИИ-агента:**
```
Подготовь к развертыванию:
1. Создай multi-stage Dockerfile для backend
2. Создай Dockerfile для frontend с nginx
3. Напиши docker-compose.yml со всеми сервисами
4. Создай подробную документацию по развертыванию
5. Добавь примеры использования с скриншотами
6. Создай видео-туториал скрипт
```

## Важные принципы для ИИ-агента

При работе с каждой итерацией ИИ-агент должен следовать этим принципам:

**Принцип постепенности**: Каждая итерация должна добавлять только один логический компонент. Не пытайтесь реализовать сразу несколько функций в одной итерации.

**Принцип тестируемости**: После каждой итерации должна быть возможность запустить и проверить новую функциональность. Всегда включайте тесты в итерацию.

**Принцип документирования**: Каждый новый компонент должен быть задокументирован. Это включает JSDoc/JavaDoc комментарии, README обновления и примеры использования.

**Принцип изоляции**: Старайтесь минимизировать изменения в существующем коде. Новая функциональность должна добавляться через расширение, а не модификацию.

**Принцип контекста**: В начале каждой сессии предоставляйте агенту контекст: что уже сделано, какая текущая структура проекта, и что конкретно нужно сделать сейчас.

Помните, что ИИ-агент работает лучше всего, когда задача четко определена и ограничена по объему. Этот план разработан так, чтобы каждая итерация была понятной, выполнимой и приводила к конкретному результату.
